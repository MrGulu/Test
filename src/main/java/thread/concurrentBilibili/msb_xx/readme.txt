1.每个线程都有每个线程单独所维护的内存，然后同一方法是在不同线程内运行的，每个方法都有自己的栈帧，都存在于栈空间里，
  线程本地的变量肯定是绑定在线程上的，不会在所谓的公共内存上。
2.可能发生脏读时才需要加锁，所以对于CopyOnWriteArrayList/CopyOnWriteArraySet来说，读时并不需要加锁。
  其写或修改的时候，都是复制一份原来的，然后在原来的基础上修改，然后将引用指向新的数据，该操作是原子性的，所以
  它写效率很低，但是读效率很高！用于写的情况很少，读的情况特别多的场景，例如事件监听器？